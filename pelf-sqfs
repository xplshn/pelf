#!/bin/sh

# shellcheck disable=SC2086 # 177 # Double quote to prevent globbing and word splitting. [SC2086] # We need word splitting

# Create a temporary directory for bundling the files
_VAR_WORKDIR="/tmp/pelf_$(date '+%s%M%S')"
_RUNTIME_FILE="$_VAR_WORKDIR/runtime"
mkdir -p "$_VAR_WORKDIR" || exit 1
# Trap all termination signals
trap 'rm -rf "$_VAR_WORKDIR"' INT TERM HUP QUIT EXIT

# Exit with error message
error() {
    printf >&2 "ERROR: %s\n" "$*"
    exit 1
}

# Log to STDERR
log() {
    printf >&2 "%s\n" "$*"
}

# Function to display usage/help information
print_help() {
    cat <<EOF
Usage: $(basename "$0") [options]

Options:
  --output-to=[filepath.sqfs.AppBundle]  Specify the output file name for the bundle
  --compression=[MKSQUASHFS_COMP_OPTS]   Specify compression flags for mksquashfs
  --add-appdir=[directory.AppDir]        Add an AppDir
  --appbundle-id=[AppBundleID]           Specify the ID of the AppBundle
  --embed-static-tools                   Embed static tools into the bundle
  --static-tools-dir=[directory]         Specify a custom directory from which to get the static tools
  --retrieve-runtime=[filepath]          Output the runtime to a file and exit
  --custom-runtime=[filepath]            Lets you specify which runtime shall be used
  --no-upx                               Disables usage of UPX compression in the static tools
  --help                                 Display this help and exit

Examples:
  $(basename "$0") --add-appdir=/path/to/appdir --appbundle-id=myapp-date-myInternetNickName --output-to=mybundle.AppBundle --compression="-comp zstd -Xcompression-level 15"
Notes:
  - pelf-sqfs is a utility for creating self-contained SQFS bundles.
  - For more information, visit https://github.com/xplshn/pelf
EOF
}

# Function to handle file/directory existence checks and operations
check_and_process() {
    FPATH="$1"
    ACTION="$2"

    if [ -e "$FPATH" ]; then
        eval "$ACTION" "$FPATH"
    else
        error "$FPATH does not exist."
    fi
}

# Parse command-line arguments using getopt
if ! ARGS=$(getopt -o "" --long output-to:,compression:,add-appdir:,appbundle-id:,static-tools-dir:,retrieve-runtime:,custom-runtime:,embed-static-tools,no-upx,help -n "$0" -- "$@"); then
    print_help
    exit 1
fi

# Evaluate the parsed arguments
eval set -- "$ARGS"

# Initialize variables
_VAR_APPDIR="" _VAR_APPBUNDLE_ID="" _VAR_OUT_FILE="" _VAR_COMPRESS_ARG="" EMBED_STATIC_TOOLS=0 _VAR_CUSTOM_EMBED_DIR="" _VAR_RETRIEVE_RUNTIME="" _VAR_NOUPX=0

# Process options
while true; do
    case "$1" in
        --help)
            print_help
            exit 0
            ;;
        --output-to)
            _VAR_OUT_FILE="$2"
            shift 2
            ;;
        --compression)
            _VAR_COMPRESS_ARG="$2"
            shift 2
            ;;
        --add-appdir)
            _VAR_APPDIR="$2"
            shift 2
            ;;
        --appbundle-id)
            _VAR_APPBUNDLE_ID="$2"
            shift 2
            ;;
        --embed-static-tools)
            EMBED_STATIC_TOOLS="1"
            shift
            ;;
        --static-tools-dir)
            _VAR_CUSTOM_EMBED_DIR="$2"
            shift 2
            ;;
        --retrieve-runtime)
            _VAR_RETRIEVE_RUNTIME="$2"
            shift 2
            ;;
        --custom-runtime)
            _VAR_CUSTOM_RUNTIME="$2"
            shift 2
            ;;
        --no-upx)
            _VAR_NOUPX="1"
            shift
            ;;
        --)
            shift
            break
            ;;
        *)
            echo "Unexpected option: $1" >&2
            print_help
            exit 1
            ;;
    esac
done

# Check for required arguments after parsing
if [ -z "$_VAR_RETRIEVE_RUNTIME" ]; then
    if [ -z "$_VAR_APPDIR" ] || [ -z "$_VAR_APPBUNDLE_ID" ] || [ -z "$_VAR_OUT_FILE" ]; then
        echo "Error: Required arguments not provided."
        echo "You must specify:"
        echo "  --add-appdir <AppDir>"
        echo "  --appbundle-id <PROGRAM-DATE-MAINTAINER>"
        echo "  --output-to <OUTPUT.AppBundle>"
        print_help
        exit 1
    fi
fi

[ -z "$_VAR_RETRIEVE_RUNTIME" ] && {
    # Check if the APPDIR exists and is a directory
    if [ -d "$_VAR_APPDIR" ]; then
        # Check for the existence of the AppRun file
        if [ ! -f "$_VAR_APPDIR/AppRun" ]; then
            echo "This AppDir does not contain an AppRun" >&2

            # Attempt to copy a generic AppRun if it exists
            if [ -f "./AppRun.generic" ]; then
                echo "Copying a generic AppRun" >&2
                cp ./AppRun.generic "$_VAR_APPDIR/AppRun"
            else
                echo "Downloading a generic AppRun..." >&2
                wget -q -O "$_VAR_APPDIR/AppRun" "https://raw.githubusercontent.com/xplshn/pelf/refs/heads/pelf-ng/assets/AppRun.generic" || {
                    echo "Failed to download AppRun." >&2
                    exit 1
                }
            fi
            chmod +x "$_VAR_APPDIR/AppRun"
        fi
    else
        echo "[$_VAR_APPDIR] is not an existing directory" >&2
        exit 1
    fi

    # Throw an error if any of these are missing
    for cmd in mksquashfs squashfuse fusermount; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            error "$cmd could not be found. Please install it and try again"
        fi
    done

    [ "$EMBED_STATIC_TOOLS" != 1 ] && [ "$_VAR_CUSTOM_EMBED_DIR" != "" ] && {
        echo "Unable to specify static-tools-dir without passing --embed-static-tools"
        exit 55
    }

    # Create a SQFS archive of the executable, libraries and additional files
    [ -n "$_VAR_COMPRESS_ARG" ] || _VAR_COMPRESS_ARG="-comp zstd -Xcompression-level 22"
    if ! mksquashfs "$_VAR_APPDIR" "$_VAR_WORKDIR/archive.sqfs" $_VAR_COMPRESS_ARG; then
        error "Compression failed"
    fi
}

# Create a self-extracting archive
if [ "$_VAR_REPRODUCIBLE" ]; then
    _VAR_HOST_INFO="$(uname -mrsp)"
else
    _VAR_HOST_INFO="$(uname -mrspv)"
fi

# If you create a new edition, please don't forget to change these two values:
CONST_VERSION="2.0_sqfs_raw" # (vanilla)
CONST_APPBUNDLE_FS="squashfs"

if [ -n "$_VAR_CUSTOM_RUNTIME" ]; then
    log "Using custom runtime: $_VAR_CUSTOM_RUNTIME"
    cp "$_VAR_CUSTOM_RUNTIME" "$_RUNTIME_FILE" || error "Failed to copy custom runtime."
else
    log "Creating default runtime."
    # Generate the default runtime script
    cat >"$_RUNTIME_FILE" <<'_END_OF_LOADER_SCRIPT'
#!/bin/sh
# __APPBUNDLE__
# This file was automatically generated by __PELF_VERSION__. Find out more about it here: https://github.com/xplshn/pelf
# Please DO NOT EDIT this file, unless you are testing for changes/fixes. If you found the need to modify
# PELF's behavior, submit a PR of your "PELF EDITION" if you think it is appropiate.                    -
# NOTE: The only way to make changes to this file is by using a `vi` implementation like Busybox's, which respects non-visible characters

# shellcheck disable=SC3028 # 18,74 # In POSIX sh, RANDOM is undefined. [SC3028] # That's ok, we also use epoch date
# shellcheck disable=SC2317 # 107,9 # Command appears to be unreachable. Check usage (or *ignore* if invoked indirectly) # We call this function via a `trap`

# Get the binary's name
[ -n "$EXE_NAME" ] || EXE_NAME="__APPBUNDLE_ID__"
# rEXE_NAME can be used as a variable name, and it is also used for creating the work dir
rEXE_NAME="$(echo "$EXE_NAME" | tr -dc '[:alnum:]_')"

# Important variables
_VAR_POOL_DIR="${TMPDIR:-/tmp}/.pelfbundles"                                                                  # Temporary pool directory
eval "_VAR_BWORK_DIR=\$${rEXE_NAME}_workDir"                                                                  # Temporary per-AppBundle work directory (allows for overrides)
[ "$_VAR_BWORK_DIR" = "" ] && _VAR_BWORK_DIR="${_VAR_POOL_DIR}/pbundle_${rEXE_NAME}$(date '+%s%M%S')_$RANDOM" # Temporary per-AppBundle work directory
_VAR_MOUNT_DIR="$_VAR_BWORK_DIR/mounted"                                                                      # Temporary directory for mounting
_VAR_EXEC_FILE="${_VAR_MOUNT_DIR}/AppRun"                                                                     # The file to execute
SELF="$(realpath "$0")"                                                                                       # Path to the .AppBundle itself
mkdir -p "$_VAR_BWORK_DIR"

# Nice variables
__RED="\x1b[0;31m"
__BLUE="\x1b[0;34m"
__YELLOW="\x1b[0;33m"
__RESET="\x1b[0m"
# Functions that are called when things aren't going well
log() {
    printf >&2 "AppBundle Runtime ${__YELLOW}Warning${__RESET}: %s\n" "$*"
}
error() {
    printf >&2 "AppBundle Runtime ${__RED}Error${__RESET}: %s\n" "$*"
    exit 1
}

# Check if squashfs is available
check_fuse() {
    # Check if squashfuse AND fusermount is available in the system PATH
    if command -v squashfuse >/dev/null && command -v fusermount >/dev/null; then
        return
    fi

    # If either squashfuse or fusermount aren't available, check if they are bundled in the script
    __STATIC_TOOLS_ARCHIVE_MARKER=$(awk '/^__STATIC_TOOLS__/ { print NR + 1; exit }' "$0") || error "Failed to locate static tools marker in the script."

    if [ -z "$__STATIC_TOOLS_ARCHIVE_MARKER" ]; then
        error "Failed to locate static tools marker in the script. No static tools where bundled and your system lacks squashfuse"
    fi

    _VAR_STATIC_TOOLS_DIR="$_VAR_BWORK_DIR/static/$(uname -om | tr ' ' '_')"

    # Ensure the directory for extracted tools exists
    mkdir -p "$_VAR_STATIC_TOOLS_DIR" || error "Failed to create directory $_VAR_STATIC_TOOLS_DIR"

    # Extract the bundled tar archive # NOTICE: Beware of bsdtar sucking, because it comes from FreeBSD
    tail -n +"$__STATIC_TOOLS_ARCHIVE_MARKER" "$0" | base64 -d 2>/dev/null | tar -xzf - -C "$_VAR_STATIC_TOOLS_DIR" || error "Failed to extract tar archive."

    # Add the extracted tools to PATH
    PATH="$PATH:$_VAR_STATIC_TOOLS_DIR" || error "Failed to update PATH with the extracted tools."

    # Check again if either squashfuse or fusermount is available
    if command -v squashfuse >/dev/null || command -v fusermount >/dev/null; then
        return
    fi
    error "Neither squashfuse nor fusermount are available in the system and were not found in the bundled archive."
}

# Mount the SquashFS archive from an offset in the script
mount_squashfs() {
    check_fuse

    # Calculate the offset by finding the line number of the marker and converting to byte offset
    __VAR_ARCHIVE_MARKER=$(grep -a -n "^__ARCHIVE_MARKER__" "$0" | cut -d: -f1)
    if [ -z "$__VAR_ARCHIVE_MARKER" ]; then
        error "Archive marker not found in script."
    fi

    # Convert line number to byte offset
    __VAR_BYTE_OFFSET=$(awk "NR == $__VAR_ARCHIVE_MARKER { print length(\$0) + 1; exit }" "$0")
    __VAR_ARCHIVE_OFFSET=$(head -n $(($__VAR_ARCHIVE_MARKER - 1)) "$0" | wc -c)

    OFFSET=$((__VAR_BYTE_OFFSET + __VAR_ARCHIVE_OFFSET))

    # Mount the embedded SquashFS archive using the offset
    mkdir -p "$_VAR_MOUNT_DIR" && \
    squashfuse -o offset="$OFFSET",ro "$0" "$_VAR_MOUNT_DIR" >/dev/null 2>&1 || error "Failed to mount SquashFS archive."
}

# Main function to handle the logic
main() {
    mount_squashfs && touch "${_VAR_BWORK_DIR}/.$$"

    cleanup() {
        (
            # Attempt to unmount
            fusermount -u "$_VAR_MOUNT_DIR" 2>/dev/null

            # Wait and check if the mount point is unmounted
            for i in 1 2 3 4 5; do
                if mountpoint -q "$_VAR_MOUNT_DIR"; then
                    sleep "$i"
                else
                    break
                fi
            done

            # Force unmount if still mounted
            if mountpoint -q "$_VAR_MOUNT_DIR"; then
                fusermount -uz "$_VAR_MOUNT_DIR" 2>/dev/null
            fi

            # Remove temporary directories
            rm -rf "$_VAR_BWORK_DIR" 2>/dev/null || true
            rm -rf "$_VAR_POOL_DIR" 2>/dev/null || true
        ) & # Run cleanup in the background
    }

    # Set up cleanup trap
    trap 'cleanup' INT TERM HUP QUIT EXIT

    _BIN_DIRs="$_VAR_MOUNT_DIR/bin:$_VAR_MOUNT_DIR/usr/bin:$_VAR_MOUNT_DIR/shared/bin"
    _LIB_DIRs="$_VAR_MOUNT_DIR/lib:$_VAR_MOUNT_DIR/usr/lib:$_VAR_MOUNT_DIR/shared/lib:$_VAR_MOUNT_DIR/lib64:$_VAR_MOUNT_DIR/usr/lib64:$_VAR_MOUNT_DIR/lib32:$_VAR_MOUNT_DIR/usr/lib32:$_VAR_MOUNT_DIR/libx32:$_VAR_MOUNT_DIR/usr/libx32"

    # Export directories with transformed variable names
    export "${rEXE_NAME}_libDir=$_LIB_DIRs"
    export "${rEXE_NAME}_binDir=$_BIN_DIRs"
    export "${rEXE_NAME}_mountDir=$_VAR_MOUNT_DIR"

    # Figure out what we do
    case "$1" in
    --pbundle_help)
        printf "This bundle was generated automatically by PELF __PELF_VERSION__, the machine on which it was created has the following \"uname -mrsp(v)\":\n %s \n" "__PELF_HOST__"
        printf "Internal variables set: \n EXE_NAME: $__BLUE%s$__RESET;\n rEXE_NAME: $__BLUE%s$__RESET;\n _VAR_MOUNT_DIR: $__BLUE%s$__RESET;\n _VAR_BWORK_DIR: $__BLUE%s$__RESET;\n" "$EXE_NAME" "$rEXE_NAME" "$_VAR_MOUNT_DIR" "$_VAR_BWORK_DIR"
        printf "Usage:\n <|--pbundle_help|--pbundle_list|--pbundle_link <binary>|--pbundle_pngIcon|--pbundle_svgIcon|--pbundle_desktop|--pbundle_appstream|--pbundle_portableHome|--pbundle_portableConfig|> <args...>\n"
        printf "NOTE: EXE_NAME is the AppBundleID -> rEXE_NAME is the AppBundleID but validated/transformed for use as a directory name & variable name\n"
        printf "NOTE: The -v option in uname may have not been saved, to allow for reproducibility (since uname -v will output the current date)\n"
        exit 1
        ;;
    --pbundle_list)
        find "$_VAR_MOUNT_DIR" && exit 0
        exit 1
        ;;
    --pbundle_link)
        if [ "$PELF_LD_VAR" = "1" ]; then
            if [ -z "$LD_LIBRARY_PATH" ]; then
                LD_LIBRARY_PATH="$_LIB_DIRs"
            else
                LD_LIBRARY_PATH="$LD_LIBRARY_PATH:$_LIB_DIRs"
            fi
            export LD_LIBRARY_PATH
        fi
        _VAR_EXEC_FILE="$2"
        shift 2
        ;;
    --pbundle_pngIcon)
        if [ -f "$_VAR_MOUNT_DIR/.DirIcon" ]; then
            base64 "$_VAR_MOUNT_DIR/.DirIcon"
            exit 0
        else
            exit 1
        fi
        ;;
    --pbundle_svgIcon)
        if [ -f "$_VAR_MOUNT_DIR/.DirIcon.svg" ]; then
            base64 "$_VAR_MOUNT_DIR/.DirIcon.svg"
            exit 0
        else
            exit 1
        fi
        ;;
    --pbundle_desktop)
        for file in "$_VAR_MOUNT_DIR"/*.desktop; do
            if [ -e "$file" ]; then
                base64 "$file"
                exit 0
            fi
        done
        exit 1
        ;;
    --pbundle_appstream)
        for file in "$_VAR_MOUNT_DIR"/*.xml; do
            if [ -e "$file" ]; then
                base64 "$file"
                exit 0
            fi
        done
        exit 1
        ;;
    --pbundle_portableHome)
        if [ -z "$WOULDBE_HOME" ] && [ -n "$WOULDBE_CONFIG" ] && [ -d "$WOULDBE_CONFIG" ]; then
            error "You cannot have a portable .home & .config of this AppBundle"
        fi
        mkdir -p "$WOULDBE_HOME"
        determine_home
        shift
        ;;
    --pbundle_portableConfig)
        if [ -z "$WOULDBE_CONFIG" ] && [ -n "$WOULDBE_HOME" ] && [ -d "$WOULDBE_HOME" ]; then
            error "You cannot have a portable .config & .home of this AppBundle"
        fi
        mkdir -p "$WOULDBE_CONFIG"
        determine_home
        shift
        ;;
    esac

    # Execute the specified file from the mounted directory
    execute_file() {
        # Add $_BIN_DIRs to the PATH
        xPATH="$_BIN_DIRs"
        # Update PATH based on PBUNDLE_OVERTAKE_PATH
        if [ "$PBUNDLE_OVERTAKE_PATH" = 1 ]; then
            PATH="$xPATH${PATH:+:$PATH}"
        else
            PATH="${PATH:+$PATH:}$xPATH"
        fi
        export PATH

        # Append to XDG_DATA_DIRS if it exists and we have ./share || ./usr/share directories
        if [ -n "$XDG_DATA_DIRS" ]; then
            [ -d "$_VAR_MOUNT_DIR/share" ] && XDG_DATA_DIRS="$XDG_DATA_DIRS:$_VAR_MOUNT_DIR/share"
            [ -d "$_VAR_MOUNT_DIR/usr/share" ] && XDG_DATA_DIRS="$XDG_DATA_DIRS:$_VAR_MOUNT_DIR/usr/share"
        fi
        export XDG_DATA_DIRS

        # Utility variables for scripting/AppRuns/wrappers
        export SELF_TEMPDIR="$_VAR_MOUNT_DIR"
        export SELF
        export ARGV0="${0##*/}" # Lots of AppDirs for AppImages expect this, it should contain the basename of "$0"

        if ! command -v "$_VAR_EXEC_FILE" >/dev/null 2>&1; then
            error "[$2] does NOT exist. It is not contained here nor is it available in the user's PATH"
        fi
        # Proceed to execute the packed ENTRY POINT binary
        "$_VAR_EXEC_FILE" "$@"
    }
    execute_file "$@"
}

main "$@"

exit $?
_END_OF_LOADER_SCRIPT
fi

# Create RUNTIME
[ -z "$_VAR_RETRIEVE_RUNTIME" ] || {
    cp "$_RUNTIME_FILE" "$_VAR_RETRIEVE_RUNTIME"
    log "Successfully wrote exported the runtime to \"$_VAR_RETRIEVE_RUNTIME\""
    log "   Notes:
        1. Add the marker for the static tools tgz prior to embedding the sqfs archive. Remember to convert the tgz archive to base64 and only after adding the marker add the base64 static.tgz archive to this runtime
        2. After that, add the sqfs archive to the runtime (this file)
        3. Then mark as executable and you're good to go"
    exit 0
}

if head -n 1 "$_RUNTIME_FILE" | grep -q '^#!'; then
    log "The runtime is a script"
    # The file is a normal text file, perform replacements directly
    sed -e "s|__APPBUNDLE_ID__|${_VAR_APPBUNDLE_ID##*/}|g" \
        -e "s|__PELF_VERSION__|${CONST_VERSION}|g" \
        -e "s|__PELF_HOST__|${_VAR_HOST_INFO}|g" \
        "$_RUNTIME_FILE" > "$_VAR_OUT_FILE"
else
    cp "$_RUNTIME_FILE" "$_VAR_OUT_FILE"
    log "Injecting internal variables into binary runtime"
    printf "\n__APPBUNDLE_ID__: %s\n__PELF_VERSION__: %s\n__PELF_HOST__: %s\n__APPBUNDLE_FS__: %s" \
        "${_VAR_APPBUNDLE_ID##*/}" "${CONST_VERSION}" "${_VAR_HOST_INFO}" "${CONST_APPBUNDLE_FS}" >> "$_VAR_OUT_FILE"
fi

embed_static_tools() {
    _VAR_STATIC_TOOLS_DIR="$_VAR_WORKDIR/static/$(uname -om | tr ' ' '_')"
    # Create the static tools directory
    mkdir -p "$_VAR_STATIC_TOOLS_DIR" || error "Failed to create directory $_VAR_WORKDIR/static"

    # Check if _VAR_CUSTOM_EMBED_DIR is set and use it; otherwise, use `which` to find the tools
    if [ -n "$_VAR_CUSTOM_EMBED_DIR" ]; then
        # Ensure the custom embed directory exists
        if [ ! -d "$_VAR_CUSTOM_EMBED_DIR" ]; then
            error "Custom embed directory $_VAR_CUSTOM_EMBED_DIR does not exist"
        fi

        # Copy the tools from the custom embed directory
        if ! cp "$_VAR_CUSTOM_EMBED_DIR/fusermount" "$_VAR_CUSTOM_EMBED_DIR/squashfuse" "$_VAR_STATIC_TOOLS_DIR"; then
            error "Failed to copy static tools from custom embed directory"
        fi
    else
        # Copy static tools using `which`
        if ! cp "$(which fusermount)" "$(which squashfuse)" "$_VAR_STATIC_TOOLS_DIR"; then
            error "Failed to copy static tools"
        fi
    fi

    if [ -z "$_VAR_NOUPX" ]; then
        if command -v "upx" >/dev/null 2>&1; then
            for file in "$_VAR_STATIC_TOOLS_DIR"/*; do
                upx "$file" >/dev/null 2>&1
            done
        fi
    fi

    # Create the tar archive
    if ! tar -C "$_VAR_STATIC_TOOLS_DIR" -czf "$_VAR_WORKDIR/static.tgz" .; then
        error "Compression of static tools failed"
    fi

    # Append the marker and the tar archive to the output file
	printf "\n__STATIC_TOOLS__\n" >>"$_VAR_OUT_FILE" || error "Failed to write marker (TAR) to output file"
	base64 <"$_VAR_WORKDIR/static.tgz" >>"$_VAR_OUT_FILE" || error "Failed to append (TAR) archive to output file"
	printf "__STATIC_TOOLS_EOF__\n">>"$_VAR_OUT_FILE" || error "Failed to write end marker (TAR) to output file"
}

[ -n "$EMBED_STATIC_TOOLS" ] && embed_static_tools

# Append the SQFS archive to the self-extracting script
printf "\n__ARCHIVE_MARKER__\n" >>"$_VAR_OUT_FILE" || error "Failed to write marker (SQFS) to output file"
cat <"$_VAR_WORKDIR/archive.sqfs" >>"$_VAR_OUT_FILE" || error "Failed to append SQFS archive to output file"

# Make the self-extracting script executable
chmod +x "$_VAR_OUT_FILE" || error "Could not mark output file as executable"
