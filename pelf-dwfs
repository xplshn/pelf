#!/bin/sh

# Create a temporary directory for bundling the files
_VAR_WORKDIR="/tmp/pelf_$(date '+%s%M%S')"
_VAR_TO_BE_BUNDLED="$_VAR_WORKDIR/blob"
mkdir -p "$_VAR_TO_BE_BUNDLED" || exit 1
# Trap all termination signals
trap 'rm -rf "$_VAR_WORKDIR"' INT TERM HUP QUIT EXIT
#

# Exit with error message
error() {
    printf >&2 "ERROR: %s\n" "$*"
    exit 1
}

# Log to STDERR
log() {
    printf >&2 "%s\n" "$*"
}

# Function to display usage/help information
print_help() {
    cat <<EOF
Usage: $0 [options]

Options:
  --output-to=[filepath.dwfs.AppBundle]  Specify the output file name for the bundle.
  --compression=[MKDWARFS_COMP_OPTS]     Specify compression flags for mkdwarfs.
  --add-appdir=[directory.AppDir]        Add an AppDir.
  --appbundle-id=[AppBundleID]           Specify the ID of the AppBundle.
  --embed-static-tools                   Embed static tools into the bundle.
  --static-tools-dir=[directory]        Specify a custom directory from which to get the static tools.
  --help                                 Display this help and exit.

Examples:
  $0 --add-appdir=/path/to/appdir --appbundle-id=myapp-date-myInternetNickName --output-to=mybundle.AppBundle --compression="--max-lookback-blocks=5 --no-history --compression zstd:level=22"
Notes:
  - pelf-dwfs is a utility for creating self-contained DWFS bundles.
  - For more information, visit https://github.com/xplshn/pelf
EOF
}

# Function to handle file/directory existence checks and operations
check_and_process() {
    FPATH="$1"
    ACTION="$2"

    if [ -e "$FPATH" ]; then
        eval "$ACTION" "$FPATH"
    else
        error "$FPATH does not exist."
    fi
}

# Parse command-line arguments using getopt
if ! ARGS=$(getopt -o ho:c:a:i:e:s --long help,output-to:,compression:,add-appdir:,appbundle-id:,embed-static-tools,static-tools-dir: -n "$0" -- "$@"); then
    print_help
    exit 1
fi

# Evaluate the arguments
eval set -- "$ARGS"

# Initialize variables
__APPDIR=""
_VAR_MAIN_BINARY=""

# Process options
while true; do
    case "$1" in
        -h | --help)
            print_help
            exit 0
            ;;
        -o | --output-to)
            _VAR_OUT_FILE="$2"
            shift 2
            ;;
        -c | --compression)
            _VAR_COMPRESS_ARG="$2"
            shift 2
            ;;
        -a | --add-appdir)
            if [ -z "$2" ]; then
                echo "Error: You must specify an AppDir." >&2
                exit 1
            fi
            __APPDIR="$2"
            shift 2
            ;;
        -i | --appbundle-id)
            _VAR_MAIN_BINARY="$2"
            shift 2
            ;;
        -e | --embed-static-tools)
            EMBED_STATIC_TOOLS="1"
            shift
            ;;
        -s | --static-tools-dir)
            _VAR_CUSTOM_EMBED_DIR="$2"
            shift 2
            ;;
        --)
            shift
            break
            ;;
        *)
            echo "Unexpected option: $1" >&2
            print_help
            exit 1
            ;;
    esac
done

# Check for required arguments after parsing
if [ -z "$__APPDIR" ] || [ -z "$_VAR_MAIN_BINARY" ] || [ -z "$_VAR_OUT_FILE" ]; then
    echo "Error: Required arguments not provided."
    echo "You must specify:"
    echo "  --add-appdir <AppDir>"
    echo "  --appbundle-id <PROGRAM-DATE-MAINTAINER>"
    echo "  --output-to <OUTPUT.AppBundle>"
    print_help
    exit 1
fi

# Check if the APPDIR exists and is a directory
if [ -d "$__APPDIR" ]; then
    # Check for the existence of the AppRun file
    if [ ! -f "$__APPDIR/AppRun" ]; then
        echo "This AppDir does not contain an AppRun" >&2

        # Attempt to copy a generic AppRun if it exists
        if [ -f "./AppRun.generic" ]; then
            echo "Copying a generic AppRun" >&2
            cp ./AppRun.generic "$__APPDIR/AppRun"
        else
            echo "Downloading a generic AppRun..." >&2
            wget -q -O "$__APPDIR/AppRun" "https://raw.githubusercontent.com/xplshn/pelf/refs/heads/pelf-ng/assets/AppRun.generic" || {
                echo "Failed to download AppRun." >&2
                exit 1
            }
        fi
        chmod +x "$__APPDIR/AppRun"
    fi

    # Process the directory and copy items
    check_and_process "$__APPDIR" "true" && \
    find "$__APPDIR" -mindepth 1 -maxdepth 1 | while IFS= read -r item; do
        cp -dR "$item" "${_VAR_TO_BE_BUNDLED}/"
    done
else
    echo "[$__APPDIR] is not an existing directory" >&2
    exit 1
fi

# Throw an error if any of these are missing
for cmd in mkdwarfs dwarfs fusermount3; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
        error "$cmd could not be found. Please install it and try again"
    fi
done

# Function to handle file/directory existence checks and operations
check_and_process() {
    FPATH="$1"
    ACTION="$2"

    if [ -e "$FPATH" ]; then
        eval "$ACTION" "$FPATH"
    else
        echo "$FPATH does not exist." >&2
        exit 1
    fi
}

[ "$EMBED_STATIC_TOOLS" != 1 ] && [ "$_VAR_CUSTOM_EMBED_DIR" != "" ] && {
    echo "Unable to specify static-tools-dir without passing --embed-static-tools"
    exit 55
}

# Create a DWFS archive of the executable, libraries and additional files
[ -n "$_VAR_COMPRESS_ARG" ] || _VAR_COMPRESS_ARG="--max-lookback-blocks=3 --block-size-bits=18 --compression zstd:level=22" # --max-lookback-blocks=5 --no-history --categorize=pcmaudio --compression pcmaudio/waveform::flac:level=8:exhaustive #_VAR_COMPRESS_ARG="--max-lookback-blocks=5 --categorize=pcmaudio --compression pcmaudio/waveform::flac:level=8"
# shellcheck disable=SC2086
if ! mkdwarfs --set-owner 0 --set-group 0 --no-create-timestamp --no-history --input "$_VAR_TO_BE_BUNDLED" --output "$_VAR_WORKDIR/archive.dwfs" --progress=ascii $_VAR_COMPRESS_ARG; then
    error "Compression failed"
fi

# Create a self-extracting archive
_VAR_HOST_INFO="$(uname -mrspv)"
CONST_VERSION="1.8_dwfs_raw" # (vanilla)

# Generate the loader script with conditional LD_LIBRARY_PATH replacements
LOADER_SCRIPT=$(sed -e "s|__ENTRY_POINT__|${_VAR_MAIN_BINARY##*/}|g" \
                        -e "s|__PELF_VERSION__|${CONST_VERSION}|g" \
                        -e "s|__PELF_HOST__|${_VAR_HOST_INFO}|g" <<'_END_OF_LOADER_SCRIPT'
#!/bin/sh

# This file was automatically generated by __PELF_VERSION__. Find out more about it here: https://github.com/xplshn/pelf
# Please DO NOT EDIT this file, unless you are testing for changes/fixes. If you found the need to modify
# PELF's behavior, submit a PR of your "PELF EDITION" if you think it is appropiate.                    -
# NOTE: The only way to make changes to this file is by using a `vi` implementation like Busybox's, which respects non-visible characters

# Get the binary's name
[ -n "$EXE_NAME" ] || EXE_NAME="__ENTRY_POINT__"
# rEXE_NAME can be used as a variable name, and it is also used for creating the work dir
rEXE_NAME="$(echo "$EXE_NAME" | tr -dc '[:alnum:]_')"

# Important variables
_VAR_POOL_DIR="${TMPDIR:-/tmp}/.pelfbundles"                                        # Temporary pool directory
_VAR_BWORK_DIR="${_VAR_POOL_DIR}/pbundle_${rEXE_NAME}$(date '+%s%M%S')_${RANDOM}"   # Temporary work directory
_VAR_MOUNT_DIR="$_VAR_BWORK_DIR/mounted"                                            # Temporary directory for mounting
_VAR_EXEC_FILE="${_VAR_MOUNT_DIR}/AppRun"                                           # The file to execute
SELF="$(realpath "$0")"                                                             # Path to the .AppBundle itself
mkdir -p "$_VAR_BWORK_DIR"

# Nice variables
__RED="\033[0;31m"
__YELLOW="\033[0;33m"
__RESET="\033[0m"
# Functions that are called when things aren't going well
log() {
	printf >&2 "AppBundle Runtime ${__YELLOW}Warning${__RESET}: %s\n" "$*"
}
error() {
	printf >&2 "AppBundle Runtime ${__RED}Error${__RESET}: %s\n" "$*"
	exit 1
}

# Check if dwarfs is available
check_fuse() {
	# Check if dwarfs AND fusermount3 is available in the system PATH
	if command -v dwarfs >/dev/null && command -v fusermount3 >/dev/null; then
		return
	fi

	# If either dwarfs or fusermount is not available, check if they are bundled in the script
	__STATIC_TOOLS_ARCHIVE_MARKER=$(awk '/^__STATIC_TOOLS__/ { print NR + 1; exit }' "$0") || error "Failed to locate static tools marker in the script."

	if [ -z "$__STATIC_TOOLS_ARCHIVE_MARKER" ]; then
		error "Failed to locate static tools marker in the script. No static tools where bundled and your system lacks dwarfs"
	fi

	_VAR_STATIC_TOOLS_DIR="$_VAR_BWORK_DIR/static/$(uname -om | tr ' ' '_')"

	# Ensure the directory for extracted tools exists
	mkdir -p "$_VAR_STATIC_TOOLS_DIR" || error "Failed to create directory $_VAR_STATIC_TOOLS_DIR"

	# Extract the bundled tar archive
	tail -n +"$__STATIC_TOOLS_ARCHIVE_MARKER" "$0" | base64 -d 2>/dev/null | tar -xzf - -C "$_VAR_STATIC_TOOLS_DIR" || error "Failed to extract tar archive."

	# Add the extracted tools to PATH
	PATH="$PATH:$_VAR_STATIC_TOOLS_DIR" || error "Failed to update PATH with the extracted tools."

	# Check again if either dwarfs or fusermount is available
	if command -v dwarfs >/dev/null || command -v fusermount3 >/dev/null; then
		return
	fi
	error "Neither dwarfs nor fusermount3 are available in the system and were not found in the bundled archive."
}

# Mount the DwarFS archive from an offset in the script
mount_dwarfs() {
	check_fuse
	# Mount the embedded DwarFS archive using the offset
	mkdir -p "$_VAR_MOUNT_DIR" && {
		dwarfs -o offset="auto",ro,auto_unmount "$SELF" "$_VAR_MOUNT_DIR" >"${_VAR_BWORK_DIR}/.dwarfs.log" 2>&1 || {
			log "ERROR: Failed to mount DwarFS archive."
			log "W: DEBUG INFO:"
			log "  \$0 is set to $0"
			log "  The realpath to \$0 is $SELF"
			exit 1
		}
	}
}

# Main function to handle the logic
main() {
	mount_dwarfs && touch "${_VAR_BWORK_DIR}/.$$"
    # shellcheck disable=SC2317 # Command appears to be unreachable. Check usage (or *ignore* if invoked indirectly)
	cleanup() {
		count() {
			[ -e "$1" ] &&
				printf '%s\n' "$#" ||
				printf '%s\n' 0
		}
		fusermount3 -uz "$_VAR_MOUNT_DIR" 2>/dev/null
		rm -rf "$_VAR_BWORK_DIR" 2>/dev/null || true
		rm -rf "$_VAR_POOL_DIR" 2>/dev/null || true
	}
	# Set up cleanup trap
	trap 'cleanup' INT TERM HUP QUIT EXIT

	_BIN_DIRs="$_VAR_MOUNT_DIR/bin:$_VAR_MOUNT_DIR/usr/bin"
	_LIB_DIRs="$_VAR_MOUNT_DIR/lib:$_VAR_MOUNT_DIR/usr/lib:$_VAR_MOUNT_DIR/lib64:$_VAR_MOUNT_DIR/usr/lib64:$_VAR_MOUNT_DIR/lib32:$_VAR_MOUNT_DIR/usr/lib32:$_VAR_MOUNT_DIR/libx32:$_VAR_MOUNT_DIR/usr/libx32"

	# Add extra binaries to the PATH if they exist
	if [ "$_VAR_FOUND_RUNNING_INSTANCE" != "1" ]; then
		# Export directories with transformed variable names
		export "${rEXE_NAME}_binDir=$_BIN_DIRs"
		export "${rEXE_NAME}_libDir=$_LIB_DIRs"
		export "${rEXE_NAME}_mountDir=$_VAR_MOUNT_DIR"
	fi

	# Figure out what we do
	case "$1" in
	--pbundle_help)
		printf "This bundle was generated automatically by PELF __PELF_VERSION__, the machine on which it was created has the following \"uname -mrspv\":\n %s \n" "__PELF_HOST__"
		printf "Usage:\n <|--pbundle_help|--pbundle_list|--pbundle_link <binary>|--pbundle_pngIcon|--pbundle_svgIcon|--pbundle_desktop|--pbundle_genThumbnail|--pbundle_mount|> <args...>\n"
		exit 1
		;;
	--pbundle_list)
		find "$_VAR_MOUNT_DIR" && exit 0
		exit 1
		;;
	--pbundle_link)
		# NOTE: This would be under execute_file, except LD_LIBRARY_PATH MUSTN'T be set when using an AppRun, but we do need this var in order to run a binary manually
		if [ "$PELF_NO_LD_VAR" != "1" ]; then
			if [ -z "$LD_LIBRARY_PATH" ]; then
				LD_LIBRARY_PATH="$_LIB_DIRs"
			else
				LD_LIBRARY_PATH="$LD_LIBRARY_PATH:$_LIB_DIRs"
			fi
			export LD_LIBRARY_PATH
		fi
		_VAR_EXEC_FILE="$2"
		shift 2
		;;
	--pbundle_pngIcon)
		if [ -f "$_VAR_MOUNT_DIR/.DirIcon" ]; then
			base64 "$_VAR_MOUNT_DIR/.DirIcon"
			exit 0
		else
			exit 1
		fi
		;;
	--pbundle_svgIcon)
		if [ -f "$_VAR_MOUNT_DIR/.DirIcon.svg" ]; then
			base64 "$_VAR_MOUNT_DIR/.DirIcon.svg"
			exit 0
		else
			exit 1
		fi
		;;
	--pbundle_desktop)
		for file in "$_VAR_MOUNT_DIR"/*.desktop; do
			if [ -e "$file" ]; then
				base64 "$file"
				exit 0
			fi
		done
		exit 1
		;;
	--pbundle_genThumbnail)
		if [ -f "$_BIN_DIRs/.pelf_thumbgen" ]; then
			if [ -f "$_VAR_MOUNT_DIR/.DirIcon" ]; then
				"$_BIN_DIRs/.pelf_thumbgen" "$0" "$_VAR_MOUNT_DIR/.DirIcon"
				exit 0
			else
				log "$_VAR_MOUNT_DIR/.DirIcon does not exist"
			fi
		else
			log "Sorry, this bundle does not contain .pelf_thumbgen, add that binary if you wish to enable this functionality. (github.com/xplshn/pelf/tree/master/cmd/misc/thumbgen)"
		fi
		exit 1
		;;
	esac

	# Execute the specified file from the mounted directory
	execute_file() {
		# Add directories to that do exists to the xPATH
		[ -d "$_VAR_MOUNT_DIR/bin" ] && xPATH="${xPATH:+$xPATH:}$_VAR_MOUNT_DIR/bin"
		[ -d "$_VAR_MOUNT_DIR/usr/bin" ] && xPATH="$_VAR_MOUNT_DIR/usr/bin"
		# Update PATH based on PBUNDLE_OVERTAKE_PATH
		if [ "$PBUNDLE_OVERTAKE_PATH" = 1 ]; then
			PATH="$xPATH${PATH:+:$PATH}"
		else
			PATH="${PATH:+$PATH:}$xPATH"
		fi
		export PATH

		# Append to XDG_DATA_DIRS if it exists and we have ./share || ./usr/share directories
		if [ -n "$XDG_DATA_DIRS" ]; then
			[ -d "$_VAR_MOUNT_DIR/share" ] && XDG_DATA_DIRS="$XDG_DATA_DIRS:$_VAR_MOUNT_DIR/share"
			[ -d "$_VAR_MOUNT_DIR/usr/share" ] && XDG_DATA_DIRS="$XDG_DATA_DIRS:$_VAR_MOUNT_DIR/usr/share"
		fi
		export XDG_DATA_DIRS

		# Utility variables for scripting/AppRuns/wrappers
		export SELF_TEMPDIR="$_VAR_MOUNT_DIR"
		export SELF
		export ARGV0="${0##*/}" # Lots of AppDirs for AppImages expect this, it should containthe basename of "$0"

		if ! command -v "$_VAR_EXEC_FILE" >/dev/null 2>&1; then
			error "[$2] does NOT exist. It is not contained here nor is it available in the user's PATH"
		fi
		# Proceed to execute the packed ENTRY POINT binary
		"$_VAR_EXEC_FILE" "$@"
	}
	execute_file "$@"
}

main "$@"

exit $?
_END_OF_LOADER_SCRIPT
)

# Create RUNTIME
echo "$LOADER_SCRIPT" > "$_VAR_OUT_FILE"

embed_static_tools() {
    _VAR_STATIC_TOOLS_DIR="$_VAR_WORKDIR/static/$(uname -om | tr ' ' '_')"
    # Create the static tools directory
    mkdir -p "$_VAR_STATIC_TOOLS_DIR" || error "Failed to create directory $_VAR_WORKDIR/static"

    # Check if _VAR_CUSTOM_EMBED_DIR is set and use it; otherwise, use `which` to find the tools
    if [ -n "$_VAR_CUSTOM_EMBED_DIR" ]; then
        # Ensure the custom embed directory exists
        if [ ! -d "$_VAR_CUSTOM_EMBED_DIR" ]; then
            error "Custom embed directory $_VAR_CUSTOM_EMBED_DIR does not exist"
        fi

        # Copy the tools from the custom embed directory
        if ! cp "$_VAR_CUSTOM_EMBED_DIR/fusermount3" "$_VAR_CUSTOM_EMBED_DIR/dwarfs" "$_VAR_STATIC_TOOLS_DIR"; then
            error "Failed to copy static tools from custom embed directory"
        fi
    else
        # Copy static tools using `which`
        if ! cp "$(which fusermount3)" "$(which dwarfs)" "$_VAR_STATIC_TOOLS_DIR"; then
            error "Failed to copy static tools"
        fi
    fi

    # Create the tar archive
    if ! tar -C "$_VAR_STATIC_TOOLS_DIR" -czf "$_VAR_WORKDIR/static.tgz" .; then
        error "Compression of static tools failed"
    fi

    # Append the marker and the tar archive to the output file
    printf "\n__STATIC_TOOLS__\n" >> "$_VAR_OUT_FILE" || error "Failed to write marker (TAR) to output file"
    base64 <"$_VAR_WORKDIR/static.tgz" >> "$_VAR_OUT_FILE" || error "Failed to append TAR archive to output file"
}

[ -n "$EMBED_STATIC_TOOLS" ] && embed_static_tools

# Append the DWFS archive to the self-extracting script
printf "\n__ARCHIVE_MARKER__\n" >> "$_VAR_OUT_FILE" || error "Failed to write marker (DWFS) to output file"
cat <"$_VAR_WORKDIR/archive.dwfs" >> "$_VAR_OUT_FILE" || error "Failed to append DWFS archive to output file"

# Make the self-extracting script executable
chmod +x "$_VAR_OUT_FILE" || error "Could not mark output file as executable"
