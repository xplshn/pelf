#!/bin/sh

unset ARGV0 ARGS LD_PRELOAD LD_LIBRARY_PATH
[ "$DEBUGX" = "1" ] && set -x

print_help() {
	cat <<EOF
Usage: $0 [|-m|-n|-p|-e|-r|-c|-z|-x|-o|] <|-v|-h|>

Options:
   -m, --maintainer   Set the maintainer (required)
   -n, --name         Set the name of the app (required)
   -p, --pkg-add      Packages to add with APK (required)
   -e, --entrypoint   Set the entrypoint (required unless using --multicall)
   -z, --dontpack     Disables .dwfs.AppBundle packaging, thus leaving only the AppDir
   -x, --sharun       Processes the desired binaries with lib4bin and adds sharun. Then, it ditches the rootfs and only keeps the files specified with '-k'
   -s, --sandbox      Enable sandbox mode (uses AppRun.rootfs-based)
   -k, --keep         Moves these directories to the appdir's ./proto, this is for use with -x, to conserve the files a program may need while also removing the rest of the rootfs
   -o, --output-to    Set the output file name (optional, default: <name>-<date>.dwfs.AppBundle)
   --local            A directory from which to pick up files such as 'AppRun.sharun', 'rootfs.tgz', 'pelf-dwfs', 'bwrap', etc
   -h, --help         Display this help and exit

ENV:
     \$LOCAL_PATH      Same as the '--local' flag. Must point to a valid directory
Examples:
   # With .desktop file (enables integration with pelfd)
     $0 --maintainer animecowgirl79 --name mousepad --pkg-add mousepad --entrypoint org.xfce.mousepad.desktop
   # With binary name (disables integration with pelfd unless you manually add a .DirIcon or .desktop or both)
     $0 --maintainer animecowgirl79 --name mousepad --pkg-add mousepad --entrypoint mousepad
   # Using a custom rootfs, AppRuns, etc
     $0 --maintainer animecowgirl79 --name mousepad --pkg-add mousepad --local ./localArchLinuxResources
Notes:
     - [pelfCreator](https://github.com/xplshn/pelf/blob/pelf-ng/pelfCreator) is an experimental tool, part of the pelf project & ecosystem
     - Learn more about [pelf](https://github.com/xplshn/pelf)
EOF
}

: "${ROOTFS_URL:=https://pub.ajam.dev/utils/alpine-mini-$(uname -m)/rootfs.tar.gz}"

parse_arguments() {
	ARGS=$(getopt -o m:n:p:e:x:k:r:o:sz -l maintainer:,name:,pkg-add:,entrypoint:,sharun:,keep:,getrid:,output:,local:,sandbox,dontpack,help -- "$@") || {
		echo "Failed to parse arguments." >&2
		exit 1
	}

	eval set -- "$ARGS"

	while true; do
		case "$1" in
		-m | --maintainer)
			MAINTAINER="$2"
			shift 2
			;;
		-n | --name)
			NAME="$2"
			shift 2
			;;
		-p | --pkg-add)
			PKG_ADD="$2"
			shift 2
			;;
		-e | --entrypoint)
			ENTRYPOINT="$2"
			shift 2
			;;
		-z | --dontpack)
			DONTPACK=1
			shift
			;;
		-x | --sharun)
			SHARUN=1
			LIB4BIN_ARGS="$2"
			shift 2
			;;
		-s | --sandbox)
			SANDBOX="1"
			shift
			;;
		-k | --keep)
			TOBEKEPT_FILES="$2"
			shift 2
			;;
		-r | --getrid)
			GETRID_FILES="$2"
			shift 2
			;;
		-o | --output-to)
			OUTPUT_TO="$2"
			shift 2
			;;
		--local)
			LOCAL_PATH="$2"
			shift 2
			;;
		-h | --help)
			print_help
			exit 0
			;;
		--)
			shift
			break
			;;
		*)
			echo "Unexpected option: $1"
			print_help
			exit 1
			;;
		esac
	done
}

check_required_arguments() {
	if [ -z "$MAINTAINER" ] || [ -z "$NAME" ] || [ -z "$PKG_ADD" ]; then
		echo "Error: --maintainer, --name, and --pkg-add are required." >&2
		print_help
		exit 1
	fi

	if [ -z "$ENTRYPOINT" ]; then
		echo "Warning: The resulting AppBundle won't have a default entrypoint/fallback, because you did not specify -e/--entrypoint. It will only work as a multicall binary" >&2
	fi
}

setup_local_path() {
	if [ -n "$LOCAL_PATH" ]; then
		if [ -d "$LOCAL_PATH" ]; then
			export PATH="$LOCAL_PATH:$PATH"
		else
			echo "Error: --local path must be a directory." >&2
			exit 1
		fi
	fi
}

create_appdir() {
	DATE="$(date +%d_%m_%Y)"
	APPBUNDLE_ID="$NAME-$DATE-$MAINTAINER"
	APPDIR="$NAME-$DATE.AppDir"
	OUTPUT_TO="${OUTPUT_TO:-$NAME-$DATE.dwfs.AppBundle}"
	COMPRESSION_OPTS="${COMPRESSION_OPTS:=-l7 -C zstd:level=22 --metadata-compression null -S 19 -B 8 --order nilsimsa -W 12 -w 4}"

	mkdir -p "$APPDIR/usr/bin" "$APPDIR/rootfs"
	echo "${0##*/} $ARGS" >"$APPDIR/.genSteps" && chmod +x "$APPDIR/.genSteps"
}

download_and_extract_rootfs() {
	# Either download & extract rootfs or directly extract it from its local copy
	if [ -f "$LOCAL_PATH/rootfs.tgz" ]; then
		if ! tar xzf "$LOCAL_PATH/rootfs.tgz" -C "$APPDIR/rootfs" --no-same-permissions; then
			echo "Failed to extract local rootfs"
			exit 1
		fi
	else
		if ! wget -qO- "$ROOTFS_URL" | tar xz - -C "$APPDIR/rootfs" --no-same-permissions; then
			echo "Failed to download or extract rootfs"
			exit 1
		fi
	fi
}

add_bwrap() {
	# Either download or copy bwrap
	if [ -f "$LOCAL_PATH/bwrap" ]; then
		cp "$LOCAL_PATH/bwrap" "$APPDIR/usr/bin/bwrap"
	else
		if ! wget -qO "$APPDIR/usr/bin/bwrap" "https://bin.ajam.dev/$(uname -m)/bwrap-patched"; then
			echo "Unable to install bwrap."
			exit 1
		fi
	fi
	chmod +x "$APPDIR/usr/bin/bwrap"
}

pkg_add() {
	# Either download or copy initial AppRun
	if [ -f "$LOCAL_PATH/AppRun" ]; then
		cp "$LOCAL_PATH/AppRun.rootfs" "$APPDIR/AppRun"
	else
		if ! wget -qO "$APPDIR/AppRun" https://raw.githubusercontent.com/xplshn/pelf/refs/heads/dev/assets/AppRun.rootfs-based; then
			echo "Failed to download AppRun.rootfs-based"
			exit 1
		fi
	fi
	chmod +x "$APPDIR/AppRun"

	_command="--Xbwrap --uid 0 --gid 0 -- apk -X \"https://dl-cdn.alpinelinux.org/alpine/edge/main\" -X \"https://dl-cdn.alpinelinux.org/alpine/edge/community\" -X \"https://dl-cdn.alpinelinux.org/alpine/edge/testing\" -U --allow-untrusted --no-cache --no-interactive --initdb add \"$PKG_ADD\""

	if [ -f "$LOCAL_PATH/pkgadd.sh" ]; then
		HOME="$HOME" PWD="$PWD" PATH="$PATH" "$APPDIR/AppRun" --Xbwrap --uid 0 --gid 0 -- sh "$LOCAL_PATH/pkgadd.sh" "$PKG_ADD" || return $?
	fi

	if [ -f "$LOCAL_PATH/pkgadd" ]; then
		_command="$(cat "$LOCAL_PATH/pkgadd")"
	fi

	echo "sh" >"$APPDIR/rootfs/entrypoint"
	eval env -i HOME="$HOME" PWD="$PWD" PATH="$PATH" "$APPDIR/AppRun" "$_command"
	ENTRYPOINT_DEST="$APPDIR/entrypoint"
	[ "$SANDBOX" = "1" ] && {
		ENTRYPOINT_DEST="$APPDIR/rootfs/usr/local/bin/default"
		rm -rf "$APPDIR/proto"
		ln -f "$APPDIR/rootfs" "$APPDIR/proto"

		echo "/usr/local/bin/LAUNCH" >"$ENTRYPOINT_DEST"
		ENTRYPOINT_DEST="$APPDIR/rootfs/entrypoint"

		mkdir -p "$APPDIR/rootfs/usr/local/bin"
		# Either download or copy LAUNCH (multicall helper for rootfs-based)
		if [ -f "$LOCAL_PATH/LAUNCH" ]; then
			cp "$LOCAL_PATH/LAUNCH" "$APPDIR/rootfs/usr/local/bin/LAUNCH"
		else
			if ! wget -qO "$APPDIR/rootfs/usr/local/bin/LAUNCH" "https://raw.githubusercontent.com/xplshn/pelf/refs/heads/pelf-ng/assets/LAUNCH-multicall.rootfs.entrypoint"; then
				echo "Failed to download LAUNCH for multicall"
				exit 1
			fi
		fi
		chmod +x "$APPDIR/rootfs/usr/local/bin/LAUNCH"
		chmod +x "$APPDIR/rootfs/usr/local/bin/default"
	}
}

create_entrypoint() {
	echo "$ENTRYPOINT" >"$ENTRYPOINT_DEST"
	chmod +x "$APPDIR/entrypoint"
}

handle_desktop_file() {
	if [ "${ENTRYPOINT##*.}" = "desktop" ]; then
		if [ -f "$APPDIR/rootfs/usr/share/applications/$ENTRYPOINT" ]; then
			ln -f "$APPDIR/rootfs/usr/share/applications/$ENTRYPOINT" "$APPDIR/$ENTRYPOINT" || {
				echo "Failed to link $APPDIR/rootfs/usr/share/applications/$ENTRYPOINT"
				exit 1
			}

			ICON_NAME="$(awk -F"=" '/Icon/ {print $2; exit}' "$APPDIR/rootfs/usr/share/applications/$ENTRYPOINT" 2>/dev/null)"
			ENTRYPOINT=$(awk -F"=| " '/Exec=/ {print $2; exit}' "$APPDIR/rootfs/usr/share/applications/$ENTRYPOINT" 2>/dev/null)
			create_entrypoint

			if [ -n "$ICON_NAME" ]; then
				ICON_PATH=$(find "$APPDIR/rootfs/usr/share/icons" -type f -name "$ICON_NAME.*" 2>/dev/null | sort | head -n 1)
				if [ -n "$ICON_PATH" ]; then
					cp "$ICON_PATH" "$APPDIR/.DirIcon" || {
						echo "Failed to copy icon $ICON_PATH"
						exit 1
					}
				else
					echo "Icon $ICON_NAME not found in $APPDIR/rootfs/usr/share/icons/"
				fi
			else
				echo "No Icon entry found in $APPDIR/rootfs/usr/share/applications/$ENTRYPOINT"
			fi
		else
			echo "No such desktop file: $APPDIR/rootfs/usr/share/applications/$ENTRYPOINT"
			exit 1
		fi
	fi
}

select_structure_and_apprun() {
	if [ "$SHARUN" = "1" ]; then
		# Prepare the list of binaries to be kept
		TOBEKEPT_BIN=""
		for ITEM in $LIB4BIN_ARGS; do
			KEEP=true
			for EXCLUDED in $GETRID_FILES; do
				if [ "$ITEM" = "$EXCLUDED" ]; then
					KEEP=false
					break
				fi
			done
			if $KEEP; then
				TOBEKEPT_BIN="$TOBEKEPT_BIN $APPDIR/rootfs/$ITEM"
			fi
		done

		# shellcheck disable=SC2086 # Generate and execute lib4bin script
		printf 'LD_LIBRARY_PATH="%s/rootfs/lib:%s/rootfs/usr/lib" lib4bin --dst-dir "%s" %s\n' "$APPDIR" "$APPDIR" "$APPDIR" $TOBEKEPT_BIN >"$APPDIR/.genl4b"
		chmod +x "$APPDIR/.genl4b"

		# Either download or copy AppRun.sharun
		if "$APPDIR/.genl4b"; then
			if [ -f "$LOCAL_PATH/AppRun.sharun" ]; then
				cp "$LOCAL_PATH/AppRun.sharun" "$APPDIR/AppRun"
			else
				if ! wget -qO "$APPDIR/AppRun" \
					"https://raw.githubusercontent.com/xplshn/pelf/refs/heads/pelf-ng/assets/AppRun.sharun"; then
					echo "Failed to download AppRun.sharun, unable to proceed with the NOROOTFS procedure"
					exit 1
				fi
			fi
			chmod +x "$APPDIR/AppRun"

			[ -z "$TOBEKEPT_FILES" ] && rm -rf "$APPDIR/rootfs"

		fi
	fi

	if [ -z "$TOBEKEPT_FILES" ]; then
		[ -d "$APPDIR/proto" ] && rm -rf "$APPDIR/proto"
		mv "$APPDIR/rootfs" "$APPDIR/proto"
	else                             # We're in "proto" mode/norootfs. Let's only keep the specified files.
		for ITEM in $TOBEKEPT_FILES; do # Doesn't do anything if the var is empty
			KEEP=true
			for EXCLUDED in $GETRID_FILES; do
				if [ "$ITEM" = "$EXCLUDED" ]; then
					KEEP=false
					break
				fi
			done
			if $KEEP; then
				mkdir -p "$APPDIR/proto/$(dirname "$ITEM")"
				cp -r "$APPDIR/rootfs/$ITEM" "$APPDIR/proto/$ITEM"
			fi
		done
		rm -rf "$APPDIR/rootfs"
	fi
	chmod +x "$APPDIR/AppRun"

	# Either download or copy fuse-overlayfs
	if [ -f "$LOCAL_PATH/fuse-overlayfs" ]; then
		cp "$LOCAL_PATH/fuse-overlayfs" "$APPDIR/usr/bin/fuse-overlayfs"
	else
		if ! wget -qO "$APPDIR/usr/bin/fuse-overlayfs" \
			"https://bin.ajam.dev/$(uname -m)/fuse-overlayfs"; then
			echo "Unable to install fuse-overlayfs to $APPDIR/usr/bin/fuse-overlayfs"
			exit 1
		fi
	fi
	chmod +x "$APPDIR/usr/bin/fuse-overlayfs"

	# Either download or copy AppRun.sharun.ovfsProto
	if [ -f "$LOCAL_PATH/AppRun.sharun.ovfsProto" ]; then
		cp "$LOCAL_PATH/AppRun.sharun.ovfsProto" "$APPDIR/AppRun"
	else
		if ! wget -qO "$APPDIR/AppRun" \
			"https://raw.githubusercontent.com/xplshn/pelf/refs/heads/pelf-ng/assets/AppRun.sharun.ovfsProto"; then
			echo "Failed to download AppRun.sharun.ovfsProto, unable to proceed with the NOROOTFS procedure"
			exit 1
		fi
	fi
	chmod +x "$APPDIR/AppRun"
}

tidyup() {
	[ "$SANDBOX" != "1" ] && rm -rf "${APPDIR:?}/proto/app"
	rm -rf "${APPDIR:?}/proto/home"
	rm -rf "${APPDIR:?}/proto/__w" "${APPDIR:?}/proto/github"
	for EXCLUDED in $GETRID_FILES; do
		if [ -f "$APPDIR/proto/$EXCLUDED" ] || [ -d "$APPDIR/proto/$EXCLUDED" ]; then
			rm -rf "${APPDIR:?}/proto/$EXCLUDED"
		fi
	done
}

upx_static_tools() {
	if command -v "upx" >/dev/null 2>&1; then
		for file in "$APPDIR/usr/bin"/*; do
			upx "$file"
		done
	fi
}

create_bundle() {
	printf 'pelf-dwfs --add-appdir "%s" --appbundle-id "%s" --output-to "%s" --embed-static-tools --compression "%s"\n' "$APPDIR" "$APPBUNDLE_ID" "$OUTPUT_TO" "$COMPRESSION_OPTS" >"$APPDIR/.gen"
	chmod +x "$APPDIR/.gen"
	if [ "$DONTPACK" != "1" ]; then
		# Either download or use the local pelf-dwfs
		if [ -f "$LOCAL_PATH/pelf-dwfs" ]; then
			"$LOCAL_PATH/pelf-dwfs" --add-appdir "$APPDIR" --appbundle-id "$APPBUNDLE_ID" --output-to "$OUTPUT_TO" --embed-static-tools --compression "$COMPRESSION_OPTS"
		else
			if ! wget -qO- "https://raw.githubusercontent.com/xplshn/pelf/refs/heads/pelf-ng/pelf-dwfs" | sh -s -- --add-appdir "$APPDIR" --appbundle-id "$APPBUNDLE_ID" --output-to "$OUTPUT_TO" --embed-static-tools --compression "$COMPRESSION_OPTS"; then
				echo "Final packaging failed"
				exit 1
			fi
		fi
	fi
}

main() {
	ENTRYPOINT_DEST="$APPDIR/entrypoint"

	parse_arguments "$@"
	check_required_arguments
	setup_local_path
	create_appdir
	download_and_extract_rootfs
	# Actual logic 0------------------------------------>
	add_bwrap                                            # 1.
	pkg_add                                              # 2.
	create_entrypoint                                    # 3.
	handle_desktop_file                                  # 4.
	[ "$SANDBOX" != "1" ] && select_structure_and_apprun # 5
	tidyup                                               # 6.
	upx_static_tools                                     # 7.
	create_bundle                                        # 8.
}

main "$@"
